---
description: 
globs: 
alwaysApply: false
---
## 阶段 1: 项目设置和核心基础设施

### 分步1 初步设置

#### 项目初始化
    -创建 Next.js 14 项目 (使用 TypeScript)
    -设置 Tailwind CSS
    -配置 ESLint 和 Prettier
    -初始化 Git 仓库
    -环境配置

#### 数据库设置
    -初始化 Supabase 项目
    -创建数据库 schema
    -设置 Row Level Security (RLS):
        重点: RLS 是 Supabase 安全的核心。务必遵循最小权限原则n即默认情况下不授予任何权限n然后根据用户角色(auth.uid() 或 auth.role())精确授予 SELECT, INSERT, UPDATE, DELETE 权限。
        对于多租户应用，确保每个用户只能访问他们自己的数据，或者通过 organization_id (如果存在组织概念) 隔离数据。
        配置数据库备份 (Supabase 提供自动备份，但也可以考虑手动导出关键数据)。

### 分步2 认证和基础架构

#### Clerk 集成
    -设置 Clerk 认证
        配置社交登录提供商 (Google, GitHub 等)
        实现用户会话管理
        创建受保护路由:
        建议: 在 Next.js 的 middleware.ts 中使用 Clerk 的 clerkMiddleware 来保护路由，确保只有认证用户才能访问 dashboard, tests, gallery, settings 等页面。
        对于 API 路由，也要确保在服务器端进行权限验证，不要仅仅依赖客户端的 Clerk 状态。

#### Stripe 集成
    -设置 Creem 账户
    -配置订阅产品 (产品、价格、订阅周期)
    -实现 webhook 处理程序:
        重点: Webhook 用于监听 Stripe 事件（例如，订阅成功、失败、续订、取消）。
        安全性: 务必验证 Stripe webhook 签名,防止伪造的请求。Stripe 的 SDK 提供了验证函数。
        实现幂等性处理 webhook 事件，防止重复处理。
        创建订阅管理系统 (例如，用户在你的应用中查看和管理他们的订阅状态)。

#### Cloudinary 设置

    -配置 Cloudinary 账户
    -设置图片上传处理程序:
        建议: 后端处理上传,而不是直接从前端上传到Cloudinary,以保护你的 API 密钥。
        确保上传时应用适当的文件夹结构和命名约定。
    -实现图片优化:
        利用 Cloudinary 的自动格式 (f_auto) 和自动质量 (q_auto)。
        根据设备和显示尺寸动态调整图片大小 (w_auto, dpr_auto)。
        创建图片管理系统 (在应用中展示用户生成的图片)。


## 阶段 2: 核心功能开发

### 分步1 心理测试模块

#### 测试数据库

    -创建测试问题数据库 (问题、选项)
    -实现测试分类 (例如，人格、情绪、职业倾向)
    -设置测试结果存储 (用户ID、测试ID、生成的图片链接)


#### 设计测试 UI 组件 (问题卡片、进度条、导航按钮)
    -实现测试流程 (逐步显示问题，收集用户输入)
    -创建进度跟踪 (显示当前进度，已完成问题数量)
    -添加测试结果可视化 (文本描述)
    -生成图片显示(等待动画界面)


#### 积分系统

    -实现积分计算 (完成测试、生成图片消耗积分,新用户赠送1积分)
    -创建积分交易系统 (记录积分的增减原因和时间)
    -设置积分历史 (用户查看自己的积分流水)
    -添加积分管理 UI (显示当前积分，购买积分入口)


### 分步2  AI 集成

#### AI SDK 设置
    -配置 Google AI SDK
    -设置 Gemini 模型集成:
        重点: 仔细研究 Gemini API 的使用限制和计费模式。
        在服务器端调用 Gemini API,不要将 API 密钥暴露给前端。
    -实现 Prompt Engineering:
        核心: 根据测试结果，设计有效的 Prompt 来指导 Gemini 模型生成特定风格、情绪、特征的肖像描述。
        考虑使用少量示例 (few-shot prompting) 来提高生成质量。
        对 Prompt 进行版本控制，并进行 A/B 测试以优化生成效果。
    -创建 AI 响应处理 (解析 Gemini 返回的文本描述或图片生成指令)。

#### 图片生成
    -实现图片生成管道
        将 Gemini 生成的文本描述作为输入，调用一个文本到图像 (Text-to-Image) 模型来生成肖像。
    -创建风格预设 (例如，油画风格、赛博朋克、水彩画等，用户可以选择)
    -设置生成队列 (如果图片生成耗时较长，需要一个队列来处理用户的请求，并提供生成进度反馈)。


#### 结果处理

    -实现结果分析 (将心理测试结果与 AI 图片结合，生成个性化的解释)
    -显示图片 (将生成的图片返回到前端页面显示)
    -存储图片 (将生成的图片 URL、相关描述、用户ID 存储在 Supabase 中)。
    -后期可以添加图片后处理 (例如，扩图、调整颜色，可以借助 Cloudinary 完成操作)



## 阶段 3: 用户界面和体验

### 分步1 前端开发

#### 布局和导航
    -创建响应式布局 (桌面、平板、手机适配)
    -实现导航系统 (主页、仪表盘、测试、画廊、设置等)
    -添加用户仪表盘 (显示积分、最近测试、生成图片概览)
    -创建设置页面 (个人信息、订阅管理、偏好设置)

#### 画廊和结果
    -创建图片画廊 (展示所有用户生成的图片，可以搜索)
    -实现分享功能 (允许用户分享到社交媒体，提供图片或链接)
    -添加下载选项 (注册用户可以下载高清图片)



### 分步2 用户体验

#### 多语言支持
    -设置 i18n 系统:
        建议: 使用 next-intl,它与 Next.js App Router 结合良好。
    -将翻译文本存储在 JSON 文件中 (public/locales)。
    -实现语言切换器
    -添加翻译 (开始时至少包括中文和英文)
    -创建语言检测 (根据浏览器设置或 IP 地址自动检测语言)

#### 性能优化
    -实现懒加载:
        对于图片使用 Next.js 的 next/image 组件，并设置 loading="lazy"。
        对于不立即需要的组件或模块使用 React.lazy() 和 Suspense 进行动态导入。
    -添加缓存:
        利用 Next.js 的数据缓存功能。
        浏览器缓存静态资源。
    -优化图片:
        确保所有图片都经过 Cloudinary 优化。
        使用 WebP/AVIF 等现代图片格式。
    -改善加载时间:
        使用 Lighthouse 等工具进行性能分析，识别瓶颈。
        减小 JavaScript bundle 大小。

#### 用户反馈
    -添加加载状态 (异步操作时显示加载动画或骨架屏)
    -实现错误处理 (友好的错误提示，而不是直接抛出错误)
    -创建成功消息 (操作成功时的提示)
    -添加用户通知 (例如，图片生成完成、订阅状态变更)。



## 阶段 4: 测试

### 单元测试
    -编写组件测试:
        建议: 使用 React Testing Library，专注于用户行为，而不是内部实现细节。
        例如，测试按钮点击、表单输入、数据显示等。
    -创建 API 测试 (使用 Jest 或 Supertest 测试后端 API 路由)
    -实现集成测试 (测试多个组件或服务协同工作的情况，例如测试提交心理测试并触发 AI 图片生成)
    -添加端到端测试 (E2E):
        建议: 使用 Playwright。它可以模拟真实用户操作，测试整个应用流程，包括认证、测试完成、肖像生成和显示。
        覆盖关键用户路径，例如注册、登录、完成一次测试、查看画廊、管理订阅。

### 性能测试
    -测试加载时间 (使用 Lighthouse, WebPageTest)
    -检查 API 响应时间 (使用 Postman, k6)
    -验证图片优化 (检查图片大小、格式和加载速度)
    -测试并发用户 (模拟多用户同时访问，检查服务器响应)。

### 安全测试
    -执行安全审计 (可以自行检查 OWASP Top 10，或考虑专业的安全审计)
    -测试认证 (检查 Clerk 集成是否安全，是否存在会话劫持、暴力破解等风险)
    -验证数据保护 (检查 RLS 是否有效，敏感数据是否加密)
    -检查支付安全 (确保 Stripe 集成符合 PCI DSS 标准，webhook 验证正确)。


## 阶段 5 部署和发布

### 部署准备
    -设置生产环境 (Vercel)
    -配置监控:
        建议: 使用 Sentry (错误监控), Vercel Analytics (性能监控), Prometheus/Grafana (如果需要更深入的服务器监控)。
        设置警报，以便在出现问题时及时通知。
    -设置日志:
        建议: 将应用程序日志发送到中心化日志管理服务，例如 LogRocket, Datadog 或 CloudWatch Logs。
        清晰地记录关键事件和错误。
    -创建备份系统 (确保数据库、用户生成数据等定期备份)。

### 发布
    -部署到生产环境 (执行 npm run build 和 npm run start 或通过 CI/CD 自动部署)
    -持续监控性能 (观察实际用户数据，而不是模拟数据)
    -处理用户反馈 (设置一个反馈渠道)
    -修复关键问题 (准备快速修复流程)

### 发布后
    -收集分析数据 (使用 Google Analytics, Vercel Analytics 等，了解用户行为)
    -监控用户行为 (观察用户如何使用应用，识别痛点)
    -收集反馈 (通过问卷、用户访谈等方式)
    -规划改进 (基于数据和反馈迭代)


## 阶段6 维护和更新 (持续进行)

每周任务

    监控性能 (查看仪表盘，关注异常)
    检查错误日志 (及时发现并解决错误)
    更新依赖 (保持库的最新版本，解决安全漏洞)
    备份数据 (再次强调数据安全的重要性)。

每月任务

    审查分析数据 (评估功能使用情况、用户留存率)
    更新内容 (例如，添加新的心理测试问题、调整肖像风格描述)
    优化性能 (根据实际数据进行调整)
    规划新功能 (基于用户反馈和业务需求)。

每季度任务

    重大更新 (发布大型功能或重构)
    功能添加 (实现新的用户需求)
    安全审计 (定期检查安全漏洞，保持合规性)
    性能优化 (深入分析和优化)。

未来增强
    计划功能

    更多测试类别
    新的 AI 模型 (例如，尝试集成其他文本到图像模型，或多模态模型)
    增强自定义选项
    社交功能 (例如，用户关注、分享肖像到应用内社区)。
    技术改进

    性能优化 (持续的代码优化和架构改进)
    代码重构 (保持代码库的健康和可维护性)
    架构更新 (例如，引入消息队列处理异步任务)
    安全增强。
    用户体验

    UI/UX 改进 (基于用户测试和反馈)
    新的自定义选项

    增强分析 (更深入地了解用户行为)